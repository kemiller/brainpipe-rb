###############################################################################
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ bundle add baml sorbet-runtime
#
###############################################################################

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code.
#
# frozen_string_literal: true
# rubocop: disable
# formatter:off
# typed: false
require "baml"
require "sorbet-runtime"

require_relative "inlined"
require_relative "partial-types"
require_relative "types"
require_relative "type-registry"
require_relative "request"
require_relative "parser"

module Baml
  @instance = nil
  @do_not_use_directly_unless_you_know_what_youre_doing_runtime = nil

  def self.do_not_use_directly_unless_you_know_what_youre_doing_runtime
    if @do_not_use_directly_unless_you_know_what_youre_doing_runtime.nil?
      @do_not_use_directly_unless_you_know_what_youre_doing_runtime = Baml::Ffi::BamlRuntime.from_files("baml_src", Baml::Inlined::FILE_MAP, ENV)
    end
    @do_not_use_directly_unless_you_know_what_youre_doing_runtime
  end

  def self.Client
    if @instance.nil?
      @instance = BamlClient.new(runtime: Baml::do_not_use_directly_unless_you_know_what_youre_doing_runtime)
    end

    @instance
  end

  class BamlClient
    extend T::Sig

    sig { returns(BamlStreamClient) }
    attr_reader :stream

    sig { returns(Baml::HttpRequest) }
    attr_reader :request

    sig { returns(Baml::HttpStreamRequest) }
    attr_reader :stream_request

    sig { returns(Baml::LlmResponseParser) }
    attr_reader :parse

    sig { returns(Baml::LlmStreamParser) }
    attr_reader :parse_stream

    sig {params(runtime: Baml::Ffi::BamlRuntime, ctx_manager: Baml::Ffi::RuntimeContextManager, baml_options: T.nilable(T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry, T.any(Baml::Collector, T::Array[Baml::Collector]), T::Hash[Symbol, String])])).void}
    def initialize(runtime:, ctx_manager: nil, baml_options: nil)
      @runtime = runtime
      @ctx_manager = ctx_manager || runtime.create_context_manager()
      @stream = BamlStreamClient.new(runtime: @runtime, ctx_manager: @ctx_manager, baml_options: baml_options)
      @request = Baml::HttpRequest.new(runtime: @runtime, ctx_manager: @ctx_manager)
      @stream_request = Baml::HttpStreamRequest.new(runtime: @runtime, ctx_manager: @ctx_manager)
      @parse = Baml::LlmResponseParser.new(runtime: @runtime, ctx_manager: @ctx_manager)
      @parse_stream = Baml::LlmStreamParser.new(runtime: @runtime, ctx_manager: @ctx_manager)
      @baml_options = baml_options
    end

    sig {params(path: String).returns(BamlClient)}
    def self.from_directory(path)
      BamlClient.new(runtime: Baml::Ffi::BamlRuntime.from_directory(path, ENV))
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry, T.any(Baml::Collector, T::Array[Baml::Collector]), T::Hash[Symbol, String])]
      ).returns(Baml::Types::ImageAnalysis)
    }
    def AnalyzeImageProblems(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AnalyzeImageProblems may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb, :collector, :env]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb, :collector, :env): #{baml_options.keys - [:client_registry, :tb, :collector, :env]}")
      end

      # Merge options from initialization with those passed to the method
      # Passed options take precedence over initialization options
      effective_options = {}

      if @baml_options
        effective_options = @baml_options.dup
      end

      # Override with any options passed to this specific call
      baml_options.each do |key, value|
        effective_options[key] = value
      end

      # Use the merged options for the rest of the method
      baml_options = effective_options

      collector = if baml_options[:collector]
        baml_options[:collector].is_a?(Array) ? baml_options[:collector] : [baml_options[:collector]]
      else
        []
      end
      env = (baml_options[:env] || {}).merge(ENV.to_h)

      raw = @runtime.call_function(
        "AnalyzeImageProblems",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
        collector,
        env,
      )
      (raw.parsed_using_types(Baml::Types, Baml::PartialTypes, false))
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,instructions: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry, T.any(Baml::Collector, T::Array[Baml::Collector]), T::Hash[Symbol, String])]
      ).returns(String)
    }
    def FixImageProblems(
        *varargs,
        img:,instructions:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FixImageProblems may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb, :collector, :env]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb, :collector, :env): #{baml_options.keys - [:client_registry, :tb, :collector, :env]}")
      end

      # Merge options from initialization with those passed to the method
      # Passed options take precedence over initialization options
      effective_options = {}

      if @baml_options
        effective_options = @baml_options.dup
      end

      # Override with any options passed to this specific call
      baml_options.each do |key, value|
        effective_options[key] = value
      end

      # Use the merged options for the rest of the method
      baml_options = effective_options

      collector = if baml_options[:collector]
        baml_options[:collector].is_a?(Array) ? baml_options[:collector] : [baml_options[:collector]]
      else
        []
      end
      env = (baml_options[:env] || {}).merge(ENV.to_h)

      raw = @runtime.call_function(
        "FixImageProblems",
        {
          img: img,instructions: instructions,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
        collector,
        env,
      )
      (raw.parsed_using_types(Baml::Types, Baml::PartialTypes, false))
    end

    

    sig {params(collector: T.nilable(T.any(Baml::Collector, T::Array[Baml::Collector])), tb: T.nilable(Baml::TypeBuilder), client_registry: T.nilable(Baml::ClientRegistry), env_vars: T.nilable(T::Hash[Symbol, String])).returns(BamlClient)}
    def with_options(collector: nil, tb: nil, client_registry: nil, env_vars: nil)
      BamlClient.new(runtime: @runtime, ctx_manager: @ctx_manager, baml_options: {collector: collector, tb: tb, client_registry: client_registry, env_vars: env_vars})
    end
  end

  class BamlStreamClient
    extend T::Sig

    sig {params(runtime: Baml::Ffi::BamlRuntime, ctx_manager: Baml::Ffi::RuntimeContextManager, baml_options: T.nilable(T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry, T.any(Baml::Collector, T::Array[Baml::Collector]), T::Hash[Symbol, String])])).void}
    def initialize(runtime:, ctx_manager:, baml_options: nil)
      @runtime = runtime
      @ctx_manager = ctx_manager
      @baml_options = baml_options || {}
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry, T.any(Baml::Collector, T::Array[Baml::Collector]), T::Hash[Symbol, String])]
      ).returns(Baml::BamlStream[Baml::Types::ImageAnalysis])
    }
    def AnalyzeImageProblems(
        *varargs,
        img:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("AnalyzeImageProblems may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb, :collector, :env_vars]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb, :collector, :env_vars): #{baml_options.keys - [:client_registry, :tb, :collector, :env_vars]}")
      end

      # Merge options from initialization with those passed to the method
      baml_options = (@baml_options || {}).merge(baml_options)

      collector = if baml_options[:collector]
        baml_options[:collector].is_a?(Array) ? baml_options[:collector] : [baml_options[:collector]]
      else
        []
      end
      env = (baml_options[:env] || {}).merge(ENV.to_h)

      raw = @runtime.stream_function(
        "AnalyzeImageProblems",
        {
          img: img,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
        collector,
        env,
      )
      Baml::BamlStream[T.nilable(Baml::PartialTypes::ImageAnalysis), Baml::Types::ImageAnalysis].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    sig {
      params(
        varargs: T.untyped,
        img: Baml::Image,instructions: String,
        baml_options: T::Hash[Symbol, T.any(Baml::TypeBuilder, Baml::ClientRegistry, T.any(Baml::Collector, T::Array[Baml::Collector]), T::Hash[Symbol, String])]
      ).returns(Baml::BamlStream[String])
    }
    def FixImageProblems(
        *varargs,
        img:,instructions:,
        baml_options: {}
    )
      if varargs.any?
        
        raise ArgumentError.new("FixImageProblems may only be called with keyword arguments")
      end
      if (baml_options.keys - [:client_registry, :tb, :collector, :env_vars]).any?
        raise ArgumentError.new("Received unknown keys in baml_options (valid keys: :client_registry, :tb, :collector, :env_vars): #{baml_options.keys - [:client_registry, :tb, :collector, :env_vars]}")
      end

      # Merge options from initialization with those passed to the method
      baml_options = (@baml_options || {}).merge(baml_options)

      collector = if baml_options[:collector]
        baml_options[:collector].is_a?(Array) ? baml_options[:collector] : [baml_options[:collector]]
      else
        []
      end
      env = (baml_options[:env] || {}).merge(ENV.to_h)

      raw = @runtime.stream_function(
        "FixImageProblems",
        {
          img: img,instructions: instructions,
        },
        @ctx_manager,
        baml_options[:tb]&.instance_variable_get(:@registry),
        baml_options[:client_registry],
        collector,
        env,
      )
      Baml::BamlStream[T.nilable(String), String].new(
        ffi_stream: raw,
        ctx_manager: @ctx_manager
      )
    end

    
  end
end